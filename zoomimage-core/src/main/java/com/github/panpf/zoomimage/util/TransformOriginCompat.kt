package com.github.panpf.zoomimage.util

import com.github.panpf.zoomimage.util.internal.format
import com.github.panpf.zoomimage.util.internal.lerp
import kotlin.math.roundToInt

// todo Unit tests
// todo change to value class and support unspecified
data class TransformOriginCompat(val pivotFractionX: Float, val pivotFractionY: Float) {

    override fun toString() =
        "TransformOriginCompat(${pivotFractionX.format(2)}, ${pivotFractionY.format(2)}))"

    companion object {
        val Center = TransformOriginCompat(pivotFractionX = 0.5f, pivotFractionY = 0.5f)
    }
}


fun TransformOriginCompat.toShortString(): String =
    "${pivotFractionX.format(2)}x${pivotFractionY.format(2)}"

private val transformOriginCompatTopStart =
    TransformOriginCompat(pivotFractionX = 0f, pivotFractionY = 0f)
val TransformOriginCompat.Companion.TopStart
    get() = transformOriginCompatTopStart

operator fun TransformOriginCompat.times(operand: Float) =
    TransformOriginCompat(pivotFractionX * operand, pivotFractionY * operand)

operator fun TransformOriginCompat.div(operand: Float) =
    TransformOriginCompat(pivotFractionX / operand, pivotFractionY / operand)

/**
 * Multiplication operator with [IntSizeCompat].
 *
 * Return a new [IntSizeCompat] with the width and height multiplied by the [TransformOriginCompat.pivotFractionX] and
 * [TransformOriginCompat.pivotFractionY] respectively
 */
operator fun IntSizeCompat.times(origin: TransformOriginCompat): IntSizeCompat =
    IntSizeCompat(
        width = (this.width * origin.pivotFractionX).roundToInt(),
        height = (this.height * origin.pivotFractionY).roundToInt()
    )

/**
 * Multiplication operator with [IntSizeCompat] with reverse parameter types to maintain
 * commutative properties of multiplication
 *
 * Return a new [IntSizeCompat] with the width and height multiplied by the [TransformOriginCompat.pivotFractionX] and
 * [TransformOriginCompat.pivotFractionY] respectively
 */
operator fun TransformOriginCompat.times(size: IntSizeCompat): IntSizeCompat = size * this

/**
 * Division operator with [IntSizeCompat]
 *
 * Return a new [IntSizeCompat] with the width and height divided by [TransformOriginCompat.pivotFractionX] and
 * [TransformOriginCompat.pivotFractionY] respectively
 */
operator fun IntSizeCompat.div(origin: TransformOriginCompat): IntSizeCompat =
    IntSizeCompat(
        width = (width / origin.pivotFractionX).roundToInt(),
        height = (height / origin.pivotFractionY).roundToInt()
    )

/**
 * Linearly interpolate between two [TransformOriginCompat] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(
    start: TransformOriginCompat,
    stop: TransformOriginCompat,
    fraction: Float
): TransformOriginCompat {
    return TransformOriginCompat(
        pivotFractionX = lerp(start.pivotFractionX, stop.pivotFractionX, fraction),
        pivotFractionY = lerp(start.pivotFractionY, stop.pivotFractionY, fraction)
    )
}