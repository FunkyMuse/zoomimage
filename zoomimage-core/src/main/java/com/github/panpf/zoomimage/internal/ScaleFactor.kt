package com.github.panpf.zoomimage.internal

import com.github.panpf.zoomimage.Size
import kotlin.math.roundToInt

/**
 * Holds 2 dimensional scaling factors for horizontal and vertical axes
 */
class ScaleFactor(
    /**
     * Returns the scale factor to apply along the horizontal axis
     */
    val scaleX: Float,
    /**
     * Returns the scale factor to apply along the vertical axis
     */
    val scaleY: Float
) {

    @Suppress("NOTHING_TO_INLINE")
    inline operator fun component1(): Float = scaleX

    @Suppress("NOTHING_TO_INLINE")
    inline operator fun component2(): Float = scaleY

    /**
     * Returns a copy of this ScaleFactor instance optionally overriding the
     * scaleX or scaleY parameters
     */
    fun copy(scaleX: Float = this.scaleX, scaleY: Float = this.scaleY) = ScaleFactor(scaleX, scaleY)

    /**
     * Multiplication operator.
     *
     * Returns a [ScaleFactor] with scale x and y values multiplied by the operand
     */
    operator fun times(operand: Float) = ScaleFactor(scaleX * operand, scaleY * operand)

    /**
     * Division operator.
     *
     * Returns a [ScaleFactor] with scale x and y values divided by the operand
     */
    operator fun div(operand: Float) = ScaleFactor(scaleX / operand, scaleY / operand)

    override fun toString() = "ScaleFactor(${scaleX.roundToTenths()}, ${scaleY.roundToTenths()})"

    companion object {

        /**
         * A ScaleFactor whose [scaleX] and [scaleY] parameters are unspecified. This is a sentinel
         * value used to initialize a non-null parameter.
         * Access to scaleX or scaleY on an unspecified size is not allowed
         */
        val Unspecified = ScaleFactor(Float.NaN, Float.NaN)
    }
}

private fun Float.roundToTenths(): Float {
    val shifted = this * 10
    val decimal = shifted - shifted.toInt()
    // Kotlin's round operator rounds 0.5f down to 0. Manually compare against
    // 0.5f and round up if necessary
    val roundedShifted = if (decimal >= 0.5f) {
        shifted.toInt() + 1
    } else {
        shifted.toInt()
    }
    return roundedShifted.toFloat() / 10
}

/**
 * `false` when this is [ScaleFactor.Unspecified].
 */
inline val ScaleFactor.isSpecified: Boolean
    get() = !scaleX.isNaN() && !scaleY.isNaN()

/**
 * `true` when this is [ScaleFactor.Unspecified].
 */
inline val ScaleFactor.isUnspecified: Boolean
    get() = scaleX.isNaN() || scaleY.isNaN()

/**
 * If this [ScaleFactor] [isSpecified] then this is returned, otherwise [block] is executed
 * and its result is returned.
 */
inline fun ScaleFactor.takeOrElse(block: () -> ScaleFactor): ScaleFactor =
    if (isSpecified) this else block()

/**
 * Multiplication operator with [Size].
 *
 * Return a new [Size] with the width and height multiplied by the [ScaleFactor.scaleX] and
 * [ScaleFactor.scaleY] respectively
 */
operator fun Size.times(scaleFactor: ScaleFactor): Size =
    Size(
        (this.width * scaleFactor.scaleX).roundToInt(),
        (this.height * scaleFactor.scaleY).roundToInt()
    )

/**
 * Multiplication operator with [Size] with reverse parameter types to maintain
 * commutative properties of multiplication
 *
 * Return a new [Size] with the width and height multiplied by the [ScaleFactor.scaleX] and
 * [ScaleFactor.scaleY] respectively
 */
operator fun ScaleFactor.times(size: Size): Size = size * this

/**
 * Division operator with [Size]
 *
 * Return a new [Size] with the width and height divided by [ScaleFactor.scaleX] and
 * [ScaleFactor.scaleY] respectively
 */
operator fun Size.div(scaleFactor: ScaleFactor): Size =
    Size((width / scaleFactor.scaleX).roundToInt(), (height / scaleFactor.scaleY).roundToInt())

/**
 * Linearly interpolate between two [ScaleFactor] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(start: ScaleFactor, stop: ScaleFactor, fraction: Float): ScaleFactor {
    return ScaleFactor(
        lerp(start.scaleX, stop.scaleX, fraction),
        lerp(start.scaleY, stop.scaleY, fraction)
    )
}

/**
 * Linearly interpolate between [start] and [stop] with [fraction] fraction between them.
 */
private fun lerp(start: Float, stop: Float, fraction: Float): Float {
    return (1 - fraction) * start + fraction * stop
}