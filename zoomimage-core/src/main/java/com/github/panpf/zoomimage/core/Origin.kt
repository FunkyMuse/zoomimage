package com.github.panpf.zoomimage.core

import com.github.panpf.zoomimage.core.internal.format
import kotlin.math.roundToInt

data class Origin(
    val x: Float,
    val y: Float,
) {

    init {
        require(x in 0f..1f) { "x must be in the range [0, 1] but was $x" }
        require(y in 0f..1f) { "y must be in the range [0, 1] but was $y" }
    }

    fun isEmpty() = x == 0f && y == 0f

    /**
     * Multiplication operator.
     *
     * Returns a [Origin] with scale x and y values multiplied by the operand
     */
    operator fun times(operand: Float) = Origin(x * operand, y * operand)

    /**
     * Division operator.
     *
     * Returns a [Origin] with scale x and y values divided by the operand
     */
    operator fun div(operand: Float) = Origin(x / operand, y / operand)

    override fun toString() = "Origin(${x.format(2)}, ${y.format(2)}))"

    companion object {
        /**
         * An offset with zero magnitude.
         *
         * This can be used to represent the origin of a coordinate space.
         */
        val Zero = Origin(0f, 0f)
    }
}

/**
 * Multiplication operator with [SizeCompat].
 *
 * Return a new [SizeCompat] with the width and height multiplied by the [Origin.x] and
 * [Origin.y] respectively
 */
operator fun SizeCompat.times(scaleFactor: Origin): SizeCompat =
    SizeCompat(
        (this.width * scaleFactor.x).roundToInt(),
        (this.height * scaleFactor.y).roundToInt()
    )

/**
 * Multiplication operator with [SizeCompat] with reverse parameter types to maintain
 * commutative properties of multiplication
 *
 * Return a new [SizeCompat] with the width and height multiplied by the [Origin.x] and
 * [Origin.y] respectively
 */
operator fun Origin.times(size: SizeCompat): SizeCompat = size * this

/**
 * Division operator with [SizeCompat]
 *
 * Return a new [SizeCompat] with the width and height divided by [Origin.x] and
 * [Origin.y] respectively
 */
operator fun SizeCompat.div(scaleFactor: Origin): SizeCompat =
    SizeCompat((width / scaleFactor.x).roundToInt(), (height / scaleFactor.y).roundToInt())

/**
 * Linearly interpolate between two [Origin] parameters
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 *
 * Values for [fraction] are usually obtained from an [Animation<Float>], such as
 * an `AnimationController`.
 */
fun lerp(start: Origin, stop: Origin, fraction: Float): Origin {
    return Origin(
        lerp(start.x, stop.x, fraction),
        lerp(start.y, stop.y, fraction)
    )
}

/**
 * Linearly interpolate between [start] and [stop] with [fraction] fraction between them.
 */
private fun lerp(start: Float, stop: Float, fraction: Float): Float {
    return (1 - fraction) * start + fraction * stop
}

fun Origin.toShortString(): String = "(${x.format(2)},${y.format(2)})"