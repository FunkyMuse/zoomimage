/*
 * Copyright (C) 2022 panpf <panpfpanpf@outlook.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.github.panpf.zoomimage.view.zoom.internal

import android.graphics.Matrix
import android.graphics.Point
import android.graphics.PointF
import android.graphics.Rect
import android.graphics.RectF
import android.view.View
import android.widget.ImageView.ScaleType
import com.github.panpf.zoomimage.Edge
import com.github.panpf.zoomimage.Logger
import com.github.panpf.zoomimage.ReadMode
import com.github.panpf.zoomimage.ScrollEdge
import com.github.panpf.zoomimage.core.IntSizeCompat
import com.github.panpf.zoomimage.core.OffsetCompat
import com.github.panpf.zoomimage.core.ScaleFactorCompat
import com.github.panpf.zoomimage.core.TransformCompat
import com.github.panpf.zoomimage.core.div
import com.github.panpf.zoomimage.core.internal.DEFAULT_MEDIUM_SCALE_MULTIPLE
import com.github.panpf.zoomimage.core.internal.calculateNextStepScale
import com.github.panpf.zoomimage.core.internal.computeUserScales
import com.github.panpf.zoomimage.core.internal.limitScaleWithRubberBand
import com.github.panpf.zoomimage.core.isEmpty
import com.github.panpf.zoomimage.core.rotate
import com.github.panpf.zoomimage.core.toShortString
import com.github.panpf.zoomimage.view.internal.format
import com.github.panpf.zoomimage.view.zoom.OnDrawableSizeChangeListener
import com.github.panpf.zoomimage.view.zoom.OnMatrixChangeListener
import com.github.panpf.zoomimage.view.zoom.OnRotateChangeListener
import com.github.panpf.zoomimage.view.zoom.OnViewSizeChangeListener
import com.github.panpf.zoomimage.view.zoom.ZoomAnimationSpec
import kotlin.math.abs
import kotlin.math.roundToInt

// todo 参照 ZoomableState 重构
class ZoomEngine constructor(logger: Logger, val view: View) {

    private val logger: Logger = logger.newLogger(module = "ZoomEngine")

    private var onMatrixChangeListenerList: MutableSet<OnMatrixChangeListener>? = null
    private var onRotateChangeListenerList: MutableSet<OnRotateChangeListener>? = null
    private var onViewSizeChangeListenerList: MutableSet<OnViewSizeChangeListener>? = null
    private var onDrawableSizeChangeListenerList: MutableSet<OnDrawableSizeChangeListener>? = null

    /* Stores default scale and translate information */
    private val baseMatrix = Matrix()

    /* Stores zoom, translate and externally set rotation information generated by the user through touch events */
    private val userMatrix = Matrix()

    /* Store the fused information of baseMatrix and userMatrix for drawing */
    private val displayMatrix = Matrix()
    private val displayRectF = RectF()

    /* Cache the coordinates of the last zoom gesture, used when restoring zoom */
    private var lastScaleFocusX: Float = 0f
    private var lastScaleFocusY: Float = 0f

    private var flingRunnable: FlingRunnable? = null
    private var locationRunnable: LocationRunnable? = null
    private var animatedScaleRunnable: AnimatedScaleRunnable? = null
    private var _scrollEdge: ScrollEdge = ScrollEdge(horizontal = Edge.BOTH, vertical = Edge.BOTH)
    private var blockParentIntercept: Boolean = false
    private var dragging = false
    private var manualScaling = false

    val scrollEdge: ScrollEdge
        get() = _scrollEdge

    val isScaling: Boolean
        get() = animatedScaleRunnable?.isRunning == true || manualScaling

    val userScale: Float
        get() = userMatrix.getScale().scaleX
    val userOffset: OffsetCompat
        get() = userMatrix.getTranslation()

    val baseScale: ScaleFactorCompat
        get() = baseMatrix.getScale()
    val baseOffset: OffsetCompat
        get() = baseMatrix.getTranslation()

    val scale: ScaleFactorCompat
        get() = displayMatrix.apply { getDisplayMatrix(this) }.getScale()
    val offset: OffsetCompat
        get() = displayMatrix.apply { getDisplayMatrix(this) }.getTranslation()

    /** Allows the parent ViewGroup to intercept events while sliding to an edge */
    var allowParentInterceptOnEdge: Boolean = true
    var viewSize = IntSizeCompat.Zero
        internal set(value) {
            if (field != value) {
                field = value
                reset()
                onViewSizeChangeListenerList?.forEach {
                    it.onSizeChanged()
                }
            }
        }

    /**
     * Dimensions of the original image, which is used to calculate the scale of double-click scaling
     */
    var imageSize = IntSizeCompat.Zero
        internal set(value) {
            if (field != value) {
                field = value
                reset()
            }
        }
    var drawableSize = IntSizeCompat.Zero
        internal set(value) {
            if (field != value) {
                field = value
                reset()
                onDrawableSizeChangeListenerList?.forEach {
                    it.onSizeChanged()
                }
            }
        }
    var scaleType: ScaleType = ScaleType.FIT_CENTER
        internal set(value) {
            if (field != value) {
                field = value
                reset()
            }
        }
    var readMode: ReadMode? = null
        internal set(value) {
            if (field != value) {
                field = value
                reset()
            }
        }
    var defaultMediumScaleMultiple: Float = DEFAULT_MEDIUM_SCALE_MULTIPLE
        internal set(value) {
            if (field != value) {
                field = value
                reset()
            }
        }
    var animationSpec: ZoomAnimationSpec = ZoomAnimationSpec.Default
    var threeStepScale: Boolean = false
        internal set
    var rubberBandScale: Boolean = true
        internal set
    var minScale: Float = 1.0f
        private set
    var mediumScale: Float = 1.0f
        private set
    var maxScale: Float = 1.0f
        private set

    /**
     * Initial scale and translate for base matrix
     */
    private var baseInitialTransform: TransformCompat = TransformCompat.Origin

    /**
     * Initial scale and translate for user matrix
     */
    private var userInitialTransform: TransformCompat = TransformCompat.Origin

//    var displayTransform: TransformCompat = TransformCompat.Origin
//        private set

    private var _rotateDegrees = 0
    val rotateDegrees: Int
        get() = _rotateDegrees


    /**************************************** Internal ********************************************/

    init {
        reset()
    }

    private fun notifyUpdateMatrix() {
        onMatrixChangeListenerList?.forEach { listener ->
            listener.onMatrixChanged()
        }
    }

    private fun reset() {
        val drawableSize = drawableSize
        val imageSize = imageSize
        val viewSize = viewSize
        if (drawableSize.isEmpty() || viewSize.isEmpty()) {
            minScale = 1.0f
            mediumScale = 1.0f
            maxScale = 1.0f
            baseInitialTransform = TransformCompat.Origin
            userInitialTransform = TransformCompat.Origin
        } else {
            val rotatedDrawableSize = drawableSize.rotate(rotateDegrees)
            val rotatedImageSize = imageSize.rotate(rotateDegrees)
            val userStepScales = computeUserScales(
                contentSize = rotatedDrawableSize,
                contentOriginSize = rotatedImageSize,
                containerSize = viewSize,
                scaleMode = scaleType.toScaleMode(),
                baseScale = scaleType.computeScaleFactor(
                    srcSize = rotatedDrawableSize,
                    dstSize = viewSize
                ),
                defaultMediumScaleMultiple = defaultMediumScaleMultiple
            )
            baseInitialTransform = scaleType
                .computeTransform(srcSize = rotatedDrawableSize, dstSize = viewSize)
            minScale = userStepScales[0] * baseInitialTransform.scaleX
            mediumScale = userStepScales[1] * baseInitialTransform.scaleX
            maxScale = userStepScales[2] * baseInitialTransform.scaleX
            val readMode = scaleType.supportReadMode()
                    && readMode?.should(srcSize = rotatedDrawableSize, dstSize = viewSize) == true
            userInitialTransform = if (readMode) {
                val readModeTransform = computeReadModeTransform(
                    srcSize = rotatedDrawableSize,
                    dstSize = viewSize,
                    scaleType = scaleType,
                )
                readModeTransform.div(baseInitialTransform.scale)
            } else {
                TransformCompat.Origin
            }
        }
        logger.d {
            "reset. viewSize=$viewSize, " +
                    "imageSize=$imageSize, " +
                    "drawableSize=$drawableSize, " +
                    "rotateDegrees=$rotateDegrees, " +
                    "scaleType=$scaleType, " +
                    "readMode=$readMode, " +
                    "minUserScale=$minScale, " +
                    "mediumUserScale=$mediumScale, " +
                    "maxUserScale=$maxScale, " +
                    "baseInitialTransform=$baseInitialTransform, " +
                    "userInitialTransform=$userInitialTransform"
        }
        resetBaseMatrix()
        resetUserMatrix()
        checkAndApplyMatrix()
    }


    /*************************************** Interaction ******************************************/

    /**
     * Scale to the specified scale. You don't have to worry about rotation degrees
     *
     * @param focalX  Scale the x coordinate of the center point on the view
     * @param focalY  Scale the y coordinate of the center point on the view
     */
    fun scale(newScale: Float, focalX: Float, focalY: Float, animate: Boolean) {
        val currentScale = scale.scaleX
        val focal = if (newScale > currentScale) {
            OffsetCompat(focalX, focalY)
        } else {
            OffsetCompat((view.right / 2).toFloat(), (view.bottom / 2).toFloat())
        }
        val limitedNewScale = newScale.coerceIn(minScale, maxScale)
        val finalFocalX = focal.x
        val finalFocalY = focal.y
        cancelFling()
        animatedScaleRunnable?.cancel()
        val newUserScale = limitedNewScale / baseScale.scaleX
        val currentUserScale = userScale
        if (animate) {
            animatedScaleRunnable = AnimatedScaleRunnable(
                engine = this@ZoomEngine,
                startScale = currentUserScale,
                endScale = newUserScale,
                scaleFocalX = finalFocalX,
                scaleFocalY = finalFocalY
            )
            animatedScaleRunnable?.start()
        } else {
            scaleBy(
                addUserScale = newUserScale / currentUserScale,
                focalX = finalFocalX,
                focalY = finalFocalY
            )
        }
    }

    /**
     * Scale to the specified scale. You don't have to worry about rotation degrees
     */
    fun scale(scale: Float, animate: Boolean = false) {
        scale(scale, (view.right / 2).toFloat(), (view.bottom / 2).toFloat(), animate)
    }

    /**
     * Rotate the image to the specified degrees
     *
     * @param degrees Rotation degrees, can only be 90°, 180°, 270°, 360°
     */
    fun rotateTo(degrees: Int) {
        require(degrees % 90 == 0) { "degrees must be in multiples of 90: $degrees" }
        if (_rotateDegrees == degrees) return

        var newDegrees = degrees % 360
        if (newDegrees <= 0) {
            newDegrees = 360 - newDegrees
        }
        _rotateDegrees = newDegrees
        reset()
        onRotateChangeListenerList?.forEach {
            it.onRotateChanged(newDegrees)
        }
    }

    /**
     * Rotate an degrees based on the current rotation degrees
     *
     * @param addDegrees Rotation degrees, can only be 90°, 180°, 270°, 360°
     */
    fun rotateBy(addDegrees: Int) {
        return rotateTo(_rotateDegrees + addDegrees)
    }

    fun getNextStepScale(): Float {
        val stepScales = if (threeStepScale) {
            floatArrayOf(minScale, mediumScale, maxScale)
        } else {
            floatArrayOf(minScale, mediumScale)
        }
        return calculateNextStepScale(stepScales, scale.scaleX)
    }

    fun doubleTap(fx: Float, fy: Float) {
        try {
            scale(
                newScale = getNextStepScale(),
                focalX = fx,
                focalY = fy,
                animate = true
            )
        } catch (e: ArrayIndexOutOfBoundsException) {
            // Can sometimes happen when getX() and getY() is called
        }
    }

    fun addOnMatrixChangeListener(listener: OnMatrixChangeListener) {
        this.onMatrixChangeListenerList = (onMatrixChangeListenerList ?: LinkedHashSet()).apply {
            add(listener)
        }
    }

    fun removeOnMatrixChangeListener(listener: OnMatrixChangeListener): Boolean {
        return onMatrixChangeListenerList?.remove(listener) == true
    }

    fun addOnRotateChangeListener(listener: OnRotateChangeListener) {
        this.onRotateChangeListenerList = (onRotateChangeListenerList ?: LinkedHashSet()).apply {
            add(listener)
        }
    }

    fun removeOnRotateChangeListener(listener: OnRotateChangeListener): Boolean {
        return onRotateChangeListenerList?.remove(listener) == true
    }

    fun addOnViewSizeChangeListener(listener: OnViewSizeChangeListener) {
        this.onViewSizeChangeListenerList =
            (onViewSizeChangeListenerList ?: LinkedHashSet()).apply {
                add(listener)
            }
    }

    fun removeOnViewSizeChangeListener(listener: OnViewSizeChangeListener): Boolean {
        return onViewSizeChangeListenerList?.remove(listener) == true
    }

    fun addOnDrawableSizeChangeListener(listener: OnDrawableSizeChangeListener) {
        this.onDrawableSizeChangeListenerList =
            (onDrawableSizeChangeListenerList ?: LinkedHashSet())
                .apply { add(listener) }
    }

    fun removeOnDrawableSizeChangeListener(listener: OnDrawableSizeChangeListener): Boolean {
        return onDrawableSizeChangeListenerList?.remove(listener) == true
    }

    fun clean() {
        animatedScaleRunnable?.cancel()
        animatedScaleRunnable = null
        locationRunnable?.cancel()
        locationRunnable = null
        flingRunnable?.cancel()
        flingRunnable = null
    }

    fun isLocationRunning(): Boolean {
        return this.locationRunnable?.isRunning == true
    }

    private fun resetBaseMatrix() {
        baseMatrix.apply {
            reset()
            val transform = baseInitialTransform
            postScale(transform.scale.scaleX, transform.scale.scaleY)
            postTranslate(transform.offset.x, transform.offset.y)
            postRotate(rotateDegrees.toFloat())
        }
    }

    private fun resetUserMatrix() {
        userMatrix.apply {
            reset()
            val userTransform = userInitialTransform
            postScale(userTransform.scale.scaleX, userTransform.scale.scaleY)
            postTranslate(userTransform.offset.x, userTransform.offset.y)
        }
    }

    private fun checkAndApplyMatrix() {
        if (checkMatrixBounds()) {
            notifyUpdateMatrix()
        }
    }

    private fun checkMatrixBounds(): Boolean {
        val displayRectF = displayRectF.apply { getDisplayRect(this) }
        if (displayRectF.isEmpty) {
            _scrollEdge = ScrollEdge(horizontal = Edge.BOTH, vertical = Edge.BOTH)
            return false
        }

        var deltaX = 0f
        val viewWidth = viewSize.width
        val displayWidth = displayRectF.width()
        when {
            displayWidth.toInt() <= viewWidth -> {
                deltaX = when (scaleType) {
                    ScaleType.FIT_START -> -displayRectF.left
                    ScaleType.FIT_END -> viewWidth - displayWidth - displayRectF.left
                    else -> (viewWidth - displayWidth) / 2 - displayRectF.left
                }
            }

            displayRectF.left.toInt() > 0 -> {
                deltaX = -displayRectF.left
            }

            displayRectF.right.toInt() < viewWidth -> {
                deltaX = viewWidth - displayRectF.right
            }
        }

        var deltaY = 0f
        val viewHeight = viewSize.height
        val displayHeight = displayRectF.height()
        when {
            displayHeight.toInt() <= viewHeight -> {
                deltaY = when (scaleType) {
                    ScaleType.FIT_START -> -displayRectF.top
                    ScaleType.FIT_END -> viewHeight - displayHeight - displayRectF.top
                    else -> (viewHeight - displayHeight) / 2 - displayRectF.top
                }
            }

            displayRectF.top.toInt() > 0 -> {
                deltaY = -displayRectF.top
            }

            displayRectF.bottom.toInt() < viewHeight -> {
                deltaY = viewHeight - displayRectF.bottom
            }
        }

        // Finally actually translate the matrix
        userMatrix.postTranslate(deltaX, deltaY)

        _scrollEdge = ScrollEdge(
            horizontal = when {
                displayWidth.toInt() <= viewWidth -> Edge.BOTH
                displayRectF.left.toInt() >= 0 -> Edge.START
                displayRectF.right.toInt() <= viewWidth -> Edge.END
                else -> Edge.NONE
            },
            vertical = when {
                displayHeight.toInt() <= viewHeight -> Edge.BOTH
                displayRectF.top.toInt() >= 0 -> Edge.START
                displayRectF.bottom.toInt() <= viewHeight -> Edge.END
                else -> Edge.NONE
            },
        )
        return true
    }

    fun offsetBy(dx: Float, dy: Float) {
        userMatrix.postTranslate(dx, dy)
        checkAndApplyMatrix()
    }

    fun offsetTo(dx: Float, dy: Float) {
        val offset = userOffset
        userMatrix.postTranslate(dx - offset.x, dy - offset.y)
        checkAndApplyMatrix()
    }

    /**
     * Locate to the location specified on the drawable image. You don't have to worry about scaling and rotation
     *
     * @param xInDrawable Drawable the x coordinate on the diagram
     * @param yInDrawable Drawable the y-coordinate on the diagram
     */
    fun location(xInDrawable: Float, yInDrawable: Float, animate: Boolean) {
        locationRunnable?.cancel()
        cancelFling()

        val (viewWidth, viewHeight) = viewSize.takeIf { !it.isEmpty() } ?: return
        val pointF = PointF(xInDrawable, yInDrawable).apply {
            rotatePoint(this, rotateDegrees, drawableSize)
        }
        val newX = pointF.x
        val newY = pointF.y
        val nowScale = scale.scaleX
        if (nowScale.format(2) == minScale.format(2)) {
            scale(
                newScale = getNextStepScale(),
                focalX = viewSize.width / 2f,
                focalY = viewSize.height / 2f,
                animate = false
            )
        }

        val displayRectF = getDisplayRect()
        val currentScale = scale
        val scaleLocationX = (newX * currentScale.scaleX).toInt()
        val scaleLocationY = (newY * currentScale.scaleY).toInt()
        val scaledLocationX =
            scaleLocationX.coerceIn(0, displayRectF.width().toInt())
        val scaledLocationY =
            scaleLocationY.coerceIn(0, displayRectF.height().toInt())
        val centerLocationX = (scaledLocationX - viewWidth / 2).coerceAtLeast(0)
        val centerLocationY = (scaledLocationY - viewHeight / 2).coerceAtLeast(0)
        val startX = abs(displayRectF.left.toInt())
        val startY = abs(displayRectF.top.toInt())
        logger.d {
            "location. inDrawable=${xInDrawable}x${yInDrawable}, start=${startX}x${startY}, end=${centerLocationX}x${centerLocationY}"
        }
        if (animate) {
            locationRunnable?.cancel()
            locationRunnable = LocationRunnable(
                context = view.context,
                engine = this@ZoomEngine,
                startX = startX,
                startY = startY,
                endX = centerLocationX,
                endY = centerLocationY
            )
            locationRunnable?.start()
        } else {
            val dx = -(centerLocationX - startX).toFloat()
            val dy = -(centerLocationY - startY).toFloat()
            offsetBy(dx, dy)
        }
    }

    fun getDisplayMatrix(matrix: Matrix) {
        matrix.set(baseMatrix)
        matrix.postConcat(userMatrix)
    }

    fun getDisplayRect(rectF: RectF) {
        val drawableSize = drawableSize
        val displayMatrix = displayMatrix.apply { getDisplayMatrix(this) }
        rectF.set(0f, 0f, drawableSize.width.toFloat(), drawableSize.height.toFloat())
        displayMatrix.mapRect(rectF)
    }

    fun getDisplayRect(): RectF {
        return RectF().apply { getDisplayRect(this) }
    }

    /**
     * Gets the area that the user can see on the drawable (not affected by rotation)
     */
    fun getVisibleRect(rect: Rect) {
        rect.setEmpty()
        val displayRectF =
            displayRectF.apply { getDisplayRect(this) }.takeIf { !it.isEmpty } ?: return
        val viewSize = viewSize.takeIf { !it.isEmpty() } ?: return
        val drawableSize = drawableSize.takeIf { !it.isEmpty() } ?: return
        val (drawableWidth, drawableHeight) = drawableSize.let {
            if (rotateDegrees % 180 == 0) it else IntSizeCompat(it.height, it.width)
        }
        val displayWidth = displayRectF.width()
        val displayHeight = displayRectF.height()
        val widthScale = displayWidth / drawableWidth
        val heightScale = displayHeight / drawableHeight
        var left: Float = if (displayRectF.left >= 0)
            0f else abs(displayRectF.left)
        var right: Float = if (displayWidth >= viewSize.width)
            viewSize.width + left else displayRectF.right - displayRectF.left
        var top: Float = if (displayRectF.top >= 0)
            0f else abs(displayRectF.top)
        var bottom: Float = if (displayHeight >= viewSize.height)
            viewSize.height + top else displayRectF.bottom - displayRectF.top
        left /= widthScale
        right /= widthScale
        top /= heightScale
        bottom /= heightScale
        rect.set(left.roundToInt(), top.roundToInt(), right.roundToInt(), bottom.roundToInt())
        reverseRotateRect(rect, rotateDegrees, drawableSize)
    }

    /**
     * Gets the area that the user can see on the drawable (not affected by rotation)
     */
    fun getVisibleRect(): Rect {
        return Rect().apply { getVisibleRect(this) }
    }

    fun touchPointToDrawablePoint(touchPoint: PointF): Point? {
        val drawableSize = drawableSize.takeIf { !it.isEmpty() } ?: return null
        val displayRect = getDisplayRect()
        if (!displayRect.contains(touchPoint.x, touchPoint.y)) {
            return null
        }

        val zoomScale = scale
        val drawableX =
            ((touchPoint.x - displayRect.left) / zoomScale.scaleX).roundToInt()
                .coerceIn(0, drawableSize.width)
        val drawableY =
            ((touchPoint.y - displayRect.top) / zoomScale.scaleY).roundToInt()
                .coerceIn(0, drawableSize.height)
        return Point(drawableX, drawableY)
    }

    /**
     * Whether you can scroll horizontally or vertical in the specified direction
     *
     * @param direction Negative to check scrolling left, positive to check scrolling right.
     */
    fun canScroll(horizontal: Boolean, direction: Int): Boolean {
        return com.github.panpf.zoomimage.core.internal.canScroll(horizontal, direction, scrollEdge)
    }

    fun doDrag(dx: Float, dy: Float) {
        logger.d { "onDrag. dx: $dx, dy: $dy" }

        userMatrix.postTranslate(dx, dy)
        checkAndApplyMatrix()

        val disallowParentInterceptOnEdge = !allowParentInterceptOnEdge
        val blockParent = blockParentIntercept
        val disallow = if (dragging || blockParent || disallowParentInterceptOnEdge) {
            logger.d {
                "onDrag. DisallowParentIntercept. dragging=$dragging, blockParent=$blockParent, disallowParentInterceptOnEdge=$disallowParentInterceptOnEdge"
            }
            true
        } else {
            val slop = view.resources.displayMetrics.density * 3
            val result = (scrollEdge.horizontal == Edge.NONE && (dx >= slop || dx <= -slop))
                    || (scrollEdge.horizontal == Edge.START && dx <= -slop)
                    || (scrollEdge.horizontal == Edge.END && dx >= slop)
                    || (scrollEdge.vertical == Edge.NONE && (dy >= slop || dy <= -slop))
                    || (scrollEdge.vertical == Edge.START && dy <= -slop)
                    || (scrollEdge.vertical == Edge.END && dy >= slop)
            val type = if (result) "DisallowParentIntercept" else "AllowParentIntercept"
            logger.d {
                "onDrag. $type. scrollEdge=${scrollEdge.horizontal}-${scrollEdge.vertical}, d=${dx}x${dy}"
            }
            dragging = result
            result
        }
        requestDisallowInterceptTouchEvent(disallow)
    }

    fun doFling(velocityX: Float, velocityY: Float) {
        logger.d {
            "fling. velocity=($velocityX, $velocityY), offset=${userOffset.toShortString()}"
        }

        flingRunnable?.cancel()
        flingRunnable = FlingRunnable(
            logger = logger,
            context = view.context,
            engine = this@ZoomEngine,
            velocityX = velocityX.toInt(),
            velocityY = velocityY.toInt()
        )
        flingRunnable?.start()
    }

    private fun cancelFling() {
        flingRunnable?.cancel()
    }

    fun doScaleBegin(): Boolean {
        logger.d { "onScaleBegin" }
        manualScaling = true
        return true
    }

    private fun scaleBy(addUserScale: Float, focalX: Float, focalY: Float) {
        userMatrix.postScale(addUserScale, addUserScale, focalX, focalY)
        checkAndApplyMatrix()
    }

    fun doScale(userScaleFactor: Float, focusX: Float, focusY: Float, dx: Float, dy: Float) {
        logger.d {
            "onScale. scaleFactor: $userScaleFactor, focusX: $focusX, focusY: $focusY, dx: $dx, dy: $dy"
        }

        /* Simulate a rubber band effect when zoomed to max or min */
        var newUserScaleFactor = userScaleFactor
        lastScaleFocusX = focusX
        lastScaleFocusY = focusY
        val currentUserScale = userScale
        val newUserScale = currentUserScale * newUserScaleFactor
        val minUserScale = minScale / baseScale.scaleX
        val maxUserScale = maxScale / baseScale.scaleX
        val limitedNewUserScale = if (rubberBandScale) {
            limitScaleWithRubberBand(
                currentScale = currentUserScale,
                targetScale = newUserScale,
                minScale = minUserScale,
                maxScale = maxUserScale,
            )
        } else {
            newUserScale.coerceIn(minimumValue = minUserScale, maximumValue = maxUserScale)
        }
        newUserScaleFactor = limitedNewUserScale / currentUserScale

        userMatrix.postScale(newUserScaleFactor, newUserScaleFactor, focusX, focusY)
        userMatrix.postTranslate(dx, dy)
        checkAndApplyMatrix()
    }

    fun doScaleEnd() {
        logger.d { "onScaleEnd" }
        manualScaling = false
        notifyUpdateMatrix()
    }

    fun actionDown() {
        logger.d {
            "onActionDown. disallow parent intercept touch event"
        }

        lastScaleFocusX = 0f
        lastScaleFocusY = 0f
        dragging = false

        requestDisallowInterceptTouchEvent(true)

        cancelFling()
    }

    fun actionUp() {
        /* Roll back to minimum or maximum scaling */
        val currentScale = scale.scaleX.format(2)
        val minScale = minScale.format(2)
        val maxScale = maxScale.format(2)
        if (currentScale < minScale) {
            val displayRectF = displayRectF.apply { getDisplayRect(this) }
            if (!displayRectF.isEmpty) {
                scale(minScale, displayRectF.centerX(), displayRectF.centerY(), true)
            }
        } else if (currentScale > maxScale) {
            val lastScaleFocusX = lastScaleFocusX
            val lastScaleFocusY = lastScaleFocusY
            if (lastScaleFocusX != 0f && lastScaleFocusY != 0f) {
                scale(maxScale, lastScaleFocusX, lastScaleFocusY, true)
            }
        }
    }

    private fun requestDisallowInterceptTouchEvent(disallowIntercept: Boolean) {
        view.parent?.requestDisallowInterceptTouchEvent(disallowIntercept)
    }
}